CPU 스케줄링 알고리즘은 운영체제의 중요한 부분으로, 어떤 프로세스가 다음에 CPU를 할당받을 것인지 결정하는 방법을 정의합니다. "준비 큐"에 있는 프로세스들은 CPU의 사용을 기다리고 있으며, 스케줄링 알고리즘에 따라 "실행 큐" 혹은 "실행 상태"로 이동하게 됩니다.

다양한 CPU 스케줄링 알고리즘이 있으며, 각각의 알고리즘은 특정 목표를 중점적으로 고려합니다. 일부 알고리즘은 응답 시간을 최적화하려고 하며, 다른 알고리즘은 CPU 사용률을 최대화하거나 작업 처리량을 극대화하는 데 중점을 둘 수 있습니다.

대표적인 CPU 스케줄링 알고리즘에는 다음과 같은 것들이 있습니다:

1. **비선점형 (Non-preemptive) 스케줄링**:
    
    - 한 번 CPU를 할당받으면 CPU burst가 종료될 때까지 CPU를 반환하지 않습니다.
    - 프로세스가 자발적으로 CPU를 놓거나, 프로세스가 종료될 때만 CPU가 다른 프로세스에게 넘어갑니다.
    
    주요 비선점형 스케줄링 알고리즘:
    
    - **FCFS(First Come First Serve)**: 프로세스가 도착한 순서대로 CPU를 할당합니다.
    - **비선점형 우선순위 스케줄링**: 한 번 CPU를 할당받은 프로세스는 CPU burst를 완료할 때까지 CPU를 계속 사용합니다. 즉, 현재 실행 중인 프로세스가 CPU를 사용하는 도중에는 더 높은 우선순위의 프로세스가 도착하더라도 그 프로세스는 CPU를 선점할 수 없습니다.
    - **SJN(Shortest Job Next) 또는 SJF(Shortest Job First)**: 가장 짧은 CPU burst time을 가진 프로세스에게 우선적으로 CPU를 할당합니다.

2. **선점형 (Preemptive) 스케줄링**:
    - 현재 실행 중인 프로세스를 중단하고 다른 프로세스에게 CPU를 넘길 수 있습니다.
    - 특정 조건이나 정책에 따라 CPU를 다른 프로세스에게 선점할 수 있습니다.
    
    주요 선점형 스케줄링 알고리즘:
    
    - **라운드 로빈(RR, Round Robin)**: 각 프로세스에게 동일한 크기의 할당 시간(quantum)을 주고, 그 시간이 끝나면 다음 프로세스에게 CPU를 넘깁니다.
    - ** 선점형 우선 순위 스케줄링**: 각 프로세스에 우선순위를 할당하고, 가장 높은 우선순위를 가진 프로세스에게 CPU를 할당합니다. 선점형 방식에서는 현재 실행 중인 프로세스보다 더 높은 우선순위의 프로세스가 도착하면 CPU를 선점합니다.
    - **다단계 큐 스케줄링**: 프로세스를 여러 큐에 분류하고, 각 큐에 다른 스케줄링 알고리즘을 적용합니다.

이러한 알고리즘들은 프로세스의 특성, 시스템의 요구사항, 사용자의 요구사항에 따라 적절히 선택되거나 결합되어 사용될 수 있습니다.

---

각 CPU 스케줄링 알고리즘은 특정 목표나 환경에 맞게 설계되었기 때문에, 각 알고리즘의 특징을 이해하는 것은 중요합니다.

1. **응답 시간 최적화**:
    
    - **SJF (Shortest Job First)**: 이 알고리즘은 가장 짧은 서비스 시간을 요구하는 프로세스를 먼저 스케줄링합니다. 짧은 작업이 빠르게 처리되기 때문에 전체적인 응답 시간이 줄어들게 됩니다. 하지만 이 알고리즘은 예측이 어렵고, 긴 작업이 계속해서 대기 상태로 밀릴 수 있어 "기아" 상태가 발생할 수 있습니다.
    - **Round Robin**: 시간 할당량(time quantum)을 갖는 이 방식은 각 프로세스에게 균등하게 시간을 할당하여 실행하므로, 대화형 시스템에서 응답 시간을 개선하는 데 유용합니다.
2. **CPU 사용률 최대화**:
    
    - **FCFS (First-Come, First-Served)**: 이 방식은 단순하고 예측 가능합니다. 그러나 짧은 작업이 긴 작업 뒤에 대기 중인 경우, 짧은 작업은 긴 작업이 완료될 때까지 기다려야 합니다. 이로 인해 평균 대기 시간이 길어질 수 있습니다.
    - **Priority Scheduling**: 우선순위가 높은 작업을 먼저 처리하는 방식입니다. 하지만 낮은 우선순위의 작업은 계속 대기해야 할 수 있으므로 기아 상태 문제가 발생할 수 있습니다.

추가적으로, 실제 시스템에서는 위의 기본 알고리즘들을 조합하거나 변형하여 특정 환경과 요구사항에 맞게 최적화된 스케줄링 방식을 적용할 수 있습니다.

---

대부분의 현대 운영체제, 특히 일반적인 다중 사용자나 다중 태스크 시스템들은 선점형 스케줄링을 기본적으로 사용합니다. 선점형 스케줄링은 시스템이 더 반응성 있게 동작하도록 해주며, 여러 프로세스나 스레드에 공평하게 시간을 할당해줄 수 있기 때문입니다.

예를 들어, Windows, Linux, macOS와 같은 주요 운영체제들은 선점형 스케줄링을 사용합니다. 이러한 OS에서는 사용자가 여러 응용 프로그램을 동시에 실행할 수 있으며, 시스템은 각 프로그램에 적절한 CPU 시간을 할당하여 거의 동시에 실행되는 것처럼 보이게 합니다.

그러나 선점형 스케줄링이 항상 최적의 선택인 것은 아닙니다. 특정 임베디드 시스템이나 리얼타임 운영체제 등의 경우에는 비선점형 스케줄링이 더 적합할 수 있습니다. 이러한 시스템에서는 실행 중인 태스크가 중요하며, 해당 태스크가 완료될 때까지 다른 태스크가 CPU를 선점하는 것을 원하지 않을 수 있습니다.