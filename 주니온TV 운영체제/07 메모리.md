# 메모리  
#### 배경지식   
- 프로세스는 실행 중인 프로그램이다. 메모리에 있는 명령어의 집합이다.
- 메모리는 바이트의 커다란 배열이며, 각각은 자신의 주소를 가지고 있다.
- CPU는 program counter를 이용하여 메모리에서 명령어를 fetch한다.
- 그리고, 명령어는 load해서 메모리에 저장하게 한다.

#### 메모리 공간
- 각각의 프로세스는 분리된 메모리 공간을 가진다.
- base 레지스터와 limit 레지스터를 통해 메모리의 주소를 구분한다. 메모리는 base 레지스터가 가리키는 값부터 base 레지스터 + limit 레지스터의 값까지 공간을 차지한다.
- CPU 하드웨어가 이 두 레지스터를 이용하여 유저모드에서 생성된 주소를 활용하여 안전하게 메모리에 접근한다.

#### 주소 묶기(address binding)
- 프로그램은 디스크에 실행가능한 이진 파일로써 존재한다.
- 실행하려면, 프로그램은 메모리에 가져와야 된다.
- 이때, 이 프로세스의 주소는 00000000으로 시작하지 않는다.
- 소스코드 상의 주소는 주로 기호로 되어있다.
- 컴파일러가 대표적으로 기호로된 주소를 재배치 가능한 주소와 묶는다.
- 링커 혹은 로더가 재배치 가능한 주소를 절대적인 주소와 묶는다.
- 논리 주소 공간 vs 물리적 주소 공간
  - 논리 주소 : CPU에 의해 생성된 주소
  - 물리 주소 : 메모리 단위에서의 주소 (메모리-주소 레지스터에 로딩된 값)
  - 논리 주소 공간 : 사용자 프로그램에 의해 생성된 모든 논리 주소들의 집합
  - 물리 주소 공간 : 이러한 논리 주소들에 상응하는 물리 주소들의 집합
- MMU(Memory Management Unit)
  - 논리 주소와 물리주소를 짝을 짓는 하드웨어 장치
  - 재배치 레지스터 : MMU안에 있는 base 레지스터
  - CPU에서 논리주소를 MMU로 보내면, MMU가 논리주소에 재배치 레지스터 값을 더해 물리 주소값으로 변경 후, 메모리에 보내준다.
 
#### 동적 로딩   
- 모든 프로그램과 데이터가 메모리에 있을 필요가 있을까?
- 동적 로딩 : 더 나은 메모리 공간을 활용도를 갖게 해준다.
- routine은 호출되기 전까지 로딩되지 않는다.
- 동적 로딩의 장점 :
  - routine은 필요할 때 로딩이 되어 relocatable linking loader가 필요한 루틴을 프로그램의 주소 테이블에 반영한다.

#### 동적 링킹과 공유 라이브러리
- DLLs : Dynamically Linked Libraries (프로그램이 실행될 때 사용자 프로그램과 링크되는 시스템 라이브러리)
- 정적 링킹 : 시스템 라이브러리들이 로더에 의해 이진 프로그램과 결합한다.
- 동적 링킹 : 동적 로딩과 유사하게, 실행될 때까지 링킹이 지연된다.
- 공유 라이브러리 : DLLs은 공유 라이브러리로 알려져 있다. 메모리 상의 DLL의 한 객체가 다른 여러개의 사용자 쓰레드에 의해 공유될 수 있다.

#### 연속 메모리 할당
- 메모리에 최대한 효율적인 방법으로 할당해야 한다.
- 메모리는 주로 두가지로 분할된다. 운영체제를 위한 부분과 사용자 프로세스를 위한 부분.
- 여러개의 사용자 프로세스는 메모리에 동시에 있어야 한다.
- 가능한 메모리를 프로세스에 어떻게 할당할까?
- 연속 메모리 할당은 각 프로세스를 메모리에 통채로 할당한다
- variable-partition scheme : 가장 단순한 방법으로써 프로세스를 다양한 부분의 메모리에 할당한다.
- 다양한 할당 방법 : 
  - first-fit : 가능한 첫번째에 할당
  - best-fit : 가능한 가장 작은 곳에 할당
  - worst-fit : 가장 큰 곳에 할당 
- 단편화
  - 외부 단편화 : 메모리에 작은 hole이 조각처럼 생겨나서 단편화가 나타난다. 각각의 공간을 합치면 충분히 큰 공간이 나오지만 연속적이지 않다. 
  => 연속 메모리 할당으로 인해 발생 
  - 내부 단편화 : 메모리에 할당된 프로세스가 요청한 메모리보다 살짝 큰 현상.
  => 페이징에 의해 발생
- segmentation : 연속 메모리 할당과 페이징의 중간 부분
  - 종류별로 크기를 나눠서 할당 

#### 페이징이란?
- 프로세스의 물리주소를 비연속적으로 관리해주는 기법
- 연속 메모리 할당의 두 문제를 극복하기 위해
  - 외부 단편화가 안 일어나게
  - 메모리 압축을 안 해도되게
- 운영체제와 하드웨어의 도움을 이용하여 구현한다.

#### 페이징의 기본 방법
- 물리 주소를 고정된 크기의 블록(frame)으로 나눈다.
- 논리 주소를 같은 크기의 블록(page)로 나눈다.
- 그러면 논리 주소 공간은 물리 주소 공간과 완전히 분리된다.
- CPU로부터 생성된 모든 주소는 두가지 부분으로 나뉜다.
  - page number (프로세스 마다 존재하는 page table의 인덱스)
  - page offset 
- 예를 들어, page 크기가 4KB, 12비트라 가정하면, page0의 0번 오프셋은 첫번째 프레임의 2의 0승 위치, page1의 0번 오프셋은 두번째 프레임의 2의 0승 위치
- CPU에 의해서 논리 주소를 물리 주소로 번역하여 메모리에 접근하는 순서
  1. page number p를 가져와서 page table의 인덱스로 활용한다.
  2. page table에 상응하는 frame number f를 가져온다.
  3. page number p를 frame number f로 교체한다.   
- page size 또는 frame size는 하드웨어에 의해 정의된다.
  - 보통 2의 제곱크기를 가지며 page 당 4KB에서 1GB를 가진다. 보통 4KB가 전형적이다.
  - 그래서 논리 주소 공간의 크기는 2<sup>m</sup>, page size가 2<sup>n</sup>이면, 최상위 m-n 비트는 page number로 정해지고, 최하위 n비트는 page offset로 정해진다. 
  - 32비트 프로세서의 경우, 페이지의 크기가 4KB라고 가정하면, 32비트 중 최상위 20비트는 페이지 번호, 최하위 12비트는 페이지 오프셋을 가리킨다. 결국, 32비트 프로세스의 경우 구분할 수 있는 논리주소의 전체 개수는 2<sup>32</sup>개, 페이지의 최대 개수는 2<sup>20</sup>개다. 2<sup>32</sup>은 약 4GB여서 32비트 프로세서에서는 프로세스 하나의 크기가 4GB를 넘으면 안된다.
- PTBR (page-table base register)
  - page-table을 메모리에 놓고, 페이지 테이블을 가리키는 CPU 안의 레지스터다.
  - 문맥교환이 빨라지지만, 메모리 접근 시간이 느려진다. 페이지 테이블을 접근 한 번하고, 실제 데이터에 접근을 하기 때문이다.
- TLB (Translation Look-aisde Buffer)  
  - 페이지 테이블과 함께 사용하는 작고 빠른 하드웨어 캐시 메모리
- 페이지 테이블에 가리키는 각 프레임 넘버에 대응하는 유효-무효 비트가 있어서 메모리를 보호해준다.
- 공유 페이지
  - 페이징의 장점은 공용 코드를 공유할 수 있다는 것이고, 이는 멀티프로그래밍 환경에서 중요한 요소이다.
  - printf()와 같은 메소드가 있는 표준 C 라이브러리 libc 같은 경우는, 각 프로세스가 libc 복사본을 로드할 수 있지만, reentrant 코드라면 공유될 수 있다.
  - reentrant 코드는 실행중 수정되지 않는 코드이다. 그래야 동기화하지 않고, 여러 쓰레드가 접근이 가능해도 문제가 없기 때문이다.
- 페이지 테이블을 구조화
  - 논리 주소 공간이 커다란만큼, 페이지 테이블도 굉장히 커다랗다.
  - 그래서, 페이지 테이블에는 계층적 구조, 해시 구조, 역전 구조 등이 있다.

#### 스와핑
- 모든 프로세스의 물리 주소 공간의 합이 실제 메모리의 물리 주소 공간을 초과해도 괜찮게 해준다.
- 따라서, 멀티프로그래밍의 정도가 커진다.
- 프로세스 명령어와 데이터가 실행되려면 메모리에 있어야 하지만, 프로세스가 부분적으로 일시적으로 메모리에서 벗어나 저장공간으로 스와핑된 수 있고, 이어진 실행을 위해 잠시 메모리에서 가져올 수 있다.
- 표준 스와핑은 모든 프로세스를 메모리와 저장공간 사이 이동을 한다. 하지만 모든 프로세스를 스와핑 하기에는 비용이 엄두도 못낼 정도로 비싸다.
- 따라서, 스와핑을 페이징과 함께 한다.
- 모든 프로세스를 스와핑하는 대신 프로세스의 페이지들이 스와핑된다.
- 따라서, 물리적 메모리를 초과하더라도, 스와핑에는 적은 숫자의 페이지만 참여하게 된다.
- 현재, 페이징은 스와핑과 함꼐하는 페이징을 일컫는다.
  - page out : 페이지를 메모리에서 저장공간으로 이동한다.
  - page in : 페이지를 저장공간에서 메모리로 이동한다. 
- 페이징은 가상 메모리와 함께 잘 작동한다.








