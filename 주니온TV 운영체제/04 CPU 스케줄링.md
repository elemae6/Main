# CPU 스케줄링   
#### CPU 스케줄링이란?   
- 멀티프로그래밍하는 운영체제의 기반 <img src="https://user-images.githubusercontent.com/81418010/221446345-f01fe4c7-dd17-4597-9813-dbb43843f3ee.png" align="right" height="350px" width="600px">
- 멀티프로그래밍의 목적 : 
  - 가능한 모든 시간에 항상 어떤 프로세스를 실행시키기 위해
  - CPU의 활용도를 최대화하기 위해
  
#### CPU 스케줄러   
- 메모리의 프로세스 중에서 '준비' 상태인 프로세스를 골라서 CPU를 해당 프로세스에 할당한다.

#### 선점형 스케줄링 vs 비선점형 스케줄링
- 비선점형 스케줄링 : 
  - 프로세스가 CPU를 선점하면 그 프로세스가 종료되거나 대기 상태로 변경되는 등 자발적으로 나올 때까지 계속 기다린다.
- 선점형 스케줄링 : 
  - 프로세스가 CPU를 선점해도 쫓아낼 수 있다.  
   
#### CPU 스케줄링의 의사 결정   
- 프로세스가 실행 -> 대기    (비선점형 스케줄링하면 된다)
- 프로세스가 실행 -> 준비    (선점형 또는 비선점형 스케줄링; 보통 성능을 위해 선점형한다)
- 프로세스가 대기 -> 준비    (선점형 또는 비선점형 스케줄링; 보통 성능을 위해 선점형한다) (대기큐에서 준비큐를 갈 때 준비큐에 있는 우선순위를 제치고 먼저 실행될 수도 있다)
- 프로세스가 종료            (비선점형 스케줄링하면 된다)

#### 디스패처란?
- CPU 스케줄러에 선택된 프로세스에 직접 CPU 코어의 제어권을 주는 역할을 한다
- 해야할 일을 정하는 것까지가 스케줄러의 일, 실제로 CPU를 프로세스에 할당하는 것이 디스패처의 일
- 넓게 보면 스케줄링은 스케줄러와 디스패처의 기능을 동시에 말한다
- 디스패처의 기능 :
  - 프로세스의 문맥교환
  - 사용자 모드로 변경
  - 사용자 프로세스의 적당한 위치로 옮기는 기능
- 결국, 문맥 교환마다 디스패처가 일을 한다.
- 디스패처 지연시간이란?
  - 한 프로세스를 멈추고 다른 프로세스를 실행하는 시간

#### CPU 스케줄링의 기준   
- CPU 활용도 : CPU를 가능한 바쁘게 하기
- 처리량(throughput) : 단위 시간 당 완료한 프로세스를 최대로 늘리기
- turnaround 시간 : 프로세스를 실행하는 데 걸리는 시간 (프로세스를 제출한 후 완료될 때까지 시간)을 최대한 줄이기
- (중요) 대기 시간 : 프로세스가 레디 큐에서 보내는 시간을 줄여서 프로세스들이 레디큐에서 대기한 시간의 합을 최대한 줄이기   
  - 대기 시간이 짧아지면 자연스럽게 CPU 활용도, 처리량도 늘어나고, turnaround도 줄어든다.
- 응답 시간 : 응답하는 데 걸리는 시간을 줄이기 (UI의 경우, 마우스 클릭 응답 시간 줄이기)

#### CPU 스케줄링 문제   
- 레디 큐에 있는 프로세스 중에 어느 프로세스를 CPU의 코어에 할당할 지 정해야 한다.

#### CPU 스케줄링 해결책 
- FCFS: First- Come, First- Serverd
- SJF : Shortest Job First (SRTF : Shortest Remaining Time first)
- RR : Round-Robin
- Priority-based
- MLQ : Multi-level Queue
- MLFQ : Multi-level Feedback Queue

#### FCFS 스케줄링   
- First-Come, First-Served: 가장 단순한 CPU 스케줄링 알고리즘
- CPU에 요청을 먼저 보낸 프로세스부터 CPU에 할당한다.
- FIFO 큐로 쉽게 구현 가능   
- FCFS로 구현할 때의 평균 대기 시간은 CPU burst시간이 제각기 크게 차이난다면 전반적으로 최소값이 아니고 상당히 다양하게 나타난다.
- 비선점형 스케줄링이다.
- 역동적인 예) CPU-bound 프로세스 한 개와 다양한 I/O-bound 프로세스가 있을 때 호송 효과(똥차 효과)가 나타난다.
  - 호송효과 (똥차 효과)란?
   -  한 개의 큰 프로세스를 기다리기 위해 다른 프로세스들이 CPU를 선점하기 위해 기다린다
   -  결국 다른 짧은 프로세스들이 먼저 CPU를 선점이 가능하도록 할 때보다 CPU와 장치의 활용도가 줄어든다.
   -  똥차 효과 : 마치, 느린 똥차 한대가 가로막아서 뒤에 여러 대의 스포츠카들도 따라서 느려진다

#### SJF 스케줄링   
- Shortest-Job-First : shortest-next-CPU-burst-first scheduling   
- SJF는 각 프로세스의 다음 CPU burst 시간과 관련있다.
- CPU가 선점이 가능하면 프로세스 중에서 가장 다음 CPU burst 시간이 짧은 프로세스를 할당한다.
- 만약 다음 CPU burst 시간이 같은 프로세스가 여러개 있으면 FCFS로 먼저 들어온 것을 할당한다.
- SJF 스케줄링 알고리즘은 입증적으로 최적이다. 프로세스들의 집합에 대한 최소 평균 대기 시간을 부여한다.
- 하지만, SJF 스케줄링은 구현이 불가능하다. 다음 CPU burst 시간이 얼만큼인지 알 수 없다.
- 따라서, SJF 스케줄링을 대략적으로 구현하기 위해 다음 CPU burst 시간을 예측한 값으로 프로세스를 고른다.
- 예측할 때는 이전 CPU burst시간의 값을 활용한 특정 공식으로 구한 지수 평균을 사용한다.
- SJF 알고리즘이 선점형일 수 있고, 비선점형일 수 있다.
- 레디 큐에 프로세스가 왔는데 이미 실행되고 있는 프로세스의 남은 시간보다 짧을 때 선점형을 사용하면은 최소 평균 대기 시간이 짧아지긴 하지만 구현하기는 어렵다. 실행되고 있는 프로세스의 남은 시간을 알기가 쉽지 않기 때문이다.

#### SRTF 스케줄링   
- Shortest-Remaining-Time-First : Preemptive SJF scheduling
- SRTF 는 실행하고 있는 프로세스를 선점하는 것이 가능하다. 반면, 비선점형 SJF는 CPU burst가 끝날 때까지 기다린다.

#### RR(Round-Robin) 스케줄링
- 시간 단위(time quantum)를 가진 선점형 FCFS
- 시간 단위는 보통 10ms에서 100ms이다.
- 준비 큐는 순환 큐로 구현된다.
- 스케줄러가 준비 큐를 돌아다니면 각 프로세스를 시간 단위(time quantum)만큼 CPU에 할당한다.
- 만약, 프로세스의 CPU burst가 시간 단위(time quantum)보다 짧으면 자발적으로 CPU를 놓아주고, 스케줄러는 레디큐의 다음 프로세스를 진행시킨다.
- 만약, 프로세스의 CPU burst가 시간 단위(time quantum)보다 길면 운영체제에 인터럽트를 일으켜서 문맥 교환을 한 후 해당 프로세스는 레디큐의 꼬리 부분으로 이동된다. 
- RR 스케줄링의 평균 대기시간은 보통 길다. 그래서 RR과 SJF를 섞어서 쓰면 유용하다.
- RR 스케줄링은 선점형이다.
- RR 스케줄링은 시간 단위(time quantum)의 크기에 따라 성능이 크게 좌우된다. 
  - 시간 단위(time quantum)가 매우 크면 FCFS와 차이가 없다.
  - 시간 단위(time quantum)가 매우 작으면 문맥교환이 너무 많이 발생하고 프로세스 진행이 느려진다. 문맥교환 시, dispatch latency가 발생한다. 시간 단위(time quantum)가 dispatch latency보다 작으면 프로세스 진행조차 안된다.

#### 우선순위 스케줄링
- 각 프로세스가 우선순위와 관련이 있어서 CPU에는 우선순위가 가장 높은 프로세스가 할당된다.
- 우선순위가 같은 프로세스는 FCFS로 할당한다.
- SJF도 우선순위 스케줄링의 일종이다. (다음 CPU burst의 크기가 클수록 우선순위가 낮게된다)
- 우선순위 스케줄링은 선점형(ex.SRTF) 혹은 비선점형(ex.SJF)이 될 수 있다.
- 우선순위 스케줄링은 기아 문제를 가지고 있다.
  - 우선순위가 낮은 프로세스는 무한정 대기할 수도 있다.
  - 따라서 aging기법 같이 시간이 지나면 우선순위를 높여주는 방법을 활용해 우선순위가 낮은 프로세스도 결국 CPU에 할당될 수 있게 해줄 수 있다.
- RR과 우선순위 스케줄링을 결합할 수 있다.
- 우선순위 스케줄링을 하되, 우선순위가 같으면 FCFS 대신 RR로 스케줄링한다.

#### 다단계 큐(MLQ; Multi-Level Queue) 스케줄링
- 우선순위가 다른 큐가 여러개 있어서 우선순위가 높은 큐를 먼저 처리하고, 그 다음 우선순위 큐를 처리한다.

#### 다단계 피드백 큐(MLFQ; Multi-Level Feedback Queue) 스케줄링
- MLQ의 경우, 우선순위가 낮은 큐의 경우 기아 문제가 발생할 수 있다. 
- 그에 대한 대안으로 MLFQ는 우선순위가 다른 큐가 여러개 있지만 우선순위가 높은 큐에서 CPU를 오랫동안 차지하면 우선순위가 낮은 큐로 이동한다. 그리고 우선순위가 높은 큐가 비어야 다음 우선순위 큐에 있는 프로세스가 실행된다. 이후, 낮은 우선순위 큐에서 너무 오래있으면 aging을 통해 우선순위가 높은 큐로 이동한다.
- 실전의 운영체제에서 멀티코어와 같이 결합하여 가장 많이 활용되지만 굉장히 복잡하다.
     
#### 쓰레드 스케줄링
- 현재 운영체제는 프로세스 스케줄링을 지원안한다.
- 대신, 커널 쓰레드를 스케줄링한다. 쓰레드 스케줄링이 너무 어려워서 프로세스 스케줄링으로 강의를 하였다.
- 사용자 쓰레드는 쓰레드 라이브러리에 의해 관리된다. 커널은 사용자 쓰레드가 어떤 것이 도는지 모른다.
- 커널은 그저 커널 쓰레드를 사용자 쓰레드와 맵핑만 해준다.
- 운영체제 커널은 CPU 스케줄링을 커널 쓰레드로 스케줄링한다.

#### Real-Time Operating System (RTOS) 스케줄링   
- Real-Time OS은 주어진 시간 내에 task를 완료하는 OS
- soft realtime vs hard realtime
- soft realtime
  - soft realtime에서는 중요한 프로세스가 안 중요한 프로세스보다 선호되는 것은 맞지만 언제 스케줄 될지는 보장이 안된다. (ex. 전화통화 중 한두 번 끊기는 경우)
  - hard realtime에서는 엄격한 요구사항이 있어서 task가 마감기한 안에 기능을 해야한다. 
 - Priority를 이용하여 구현해야 한다.




   
