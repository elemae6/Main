# 가상 메모리
#### 가상 메모리란?
- 메모리에 완전히 있지 않는 프로세스들의 실행을 가능하게 해주는 기법
- 따라서, 프로그램은 메모리의 물리 주소 공간보다 더 큰 크기를 차지해도 된다.
- 주 메모리를 매우 큰 배열의 저장공간으로 추상화하여 논리적 메모리와 물리적 메모리를 분리한다.
- 현재 운영체제는 거의 다 가상 메모리가 있을 정도로, 파일 공유, 라이브러리 공유, 프로세스 생성에서도 효과적인 메커니즘을 제공한다.

#### 가상 주소 공간
<img src="https://user-images.githubusercontent.com/81418010/222339784-db079dc1-517c-4095-b7f7-7e78d362275d.png" height="300px" width="200px" align="right">
- 프로세스가 메모리에 저장된 논리적(혹은 가상의) 그림
- 보통, 0번지와 같은 특정 논리 주소로 시작되고, 연속적 메모리로써 존재한다.
- page sharing을 통해 파일과 메모리를 두 개 이상의 프로세스들로부터 공유하게 할 수 있다.

#### 요구 페이징 (demand paging)
- 실행가능한 프로그램이 보조기억장치에서 메모리에 어떻게 로딩될지 고려해보자.
- 한 가지 방법은 전체 프로그램을 물리적 메모리에 다 로딩하는 것이다.
- 다른 하나의 방법은 요구 페이징이다.
- 요구 페이징은 필요한 페이지만 로딩하는 것이다.
- 가상 메모리 시스템에서 흔하게 사용하고 있다.
- demand-paged virtual memory에서는 페이지는 실행이 요구될 때만 로딩된다.
- 프로세스가 실행될 때, 어떤 페이지는 메모리에 있고, 어떤 페이지는 보조기억장치에 있을 수 있다.
- 이 두가지 상황을 구별하려면, 유효-무효 비트 scheme이 사용될 수 있다.
  - 유효 : 페이지가 legal하며, 메모리에 존재한다. 
  - 무효 : 페이지가 유효하지 않거나 보조기억장치에 있지 않다.
- 페이지 폴트(Page fault)를 다루는 절차
  1. 프로세스의 내부 페이지 테이블을 확인하여 메모리 접근에 대한 참조가 유효한지 안한지 확인한다.
  2. 참조가 유효하면 프로세스를 종료시킨다. 하지만 유효하되, 페이지 폴트가 일어나면 page in을 한다.
  3. 비어있는 프레임을 찾는다. (free-frame list에서 하나 가져온다)
  4. 보조기억장치에 가서 요구된 페이지를 읽은 후 새롭게 할당한 프레임에 가져온다.  
  5. 가져온 이후, 내부 페이지 테이블을 수정한다. 페이지가 현재 메모리에 있다고 수정한다.
  6. 트랩에 의해 인터럽트 받은 명령어를 다시 수행한다.

#### 순수 요구 페이징 
- 메모리가 요구되기 전까지 절대 페이지를 가져오지 않는다.
- 따라서, 프로세스를 처음 시작할 때, 메모리에는 페이지가 하나도 없다.
- 그러면 첫 명령어가 페이지 폴트를 일으키고, 해당 페이지가 page in 된다.

#### 참조 지역성의 원리
- 프로그램이 여러 새로운 페이지를 각각의 명령어 마다 접근한다면, 
 만약, 명령어를 위한 한 페이지와, 데이터를 위한 여러 페이지의 경우, 명령어 마다 페이지 폴트를 일으킬 수 있다.
- 운좋게, 이러한 일을 잘 안일어난다.
- 프로그램은 참조 지역성의 원리를 가지려는 경향이 있다.
- 따라서, 요구 페이징을 사용하면 합리적인 수행을 할 수 있다.
- 자료구조와 프로그래밍 구조를 신중하게 고르면 코드와 데이터의 지역성을 높일 수 있다.
- 이런 이유로, 페이지 폴트 비율을 낮출 수 있고, 시스템의 성능을 향상시킬 수 있다.

#### 요구 페이징에 대한 하드웨어 지원
- 페이지 테이블 : 유효 비트, 무효 비트를 체크할 수 있다.
- 보조기억장치(스와핑 공간) : 주기억장치에 있지 않는 페이지들을 보관한다. 주로, 고속 디스크 또는 NVM장치이다.

#### 명령어 재시작
- 요구 페이징의 주요한 요구사항
  - 페이지 폴트 이후 아무 명령어나 재시작할 수 있게 해준다.
- 페이지 폴트가 일어나면, 인터럽트된 프로세스의 상태가 저장된다.(레지스터, 상태 코드, 명령어 카운터 등)
- 그러므로, 프로세스는 정확히 같은 장소와 상태에서 재시작한다.
- 페이지 폴트가 명령어 패치 중에 발생하면, 명령어 패치를 재시작하면 된다.
- 페이지 폴트가 피연산자를 패치하는 중 발생하면 다시 명령어를 패치한 후 피연산자를 패치한다.

#### Free frame list
- 페이지 폴트가 발생하면, 운영체제는 요구된 페이지를 보조 기억장치에서 주 기억장치로 가져와야 한다.
- 이러한 페이지 폴트를 해결하기 위해, 운영체제는 free frame list를 유지한다. 요구들을 만족하는 비어있는 프레임의 공동 이용 자원이다.
- free frame은 스택이나 힙 세그먼트를 통해 관리해줘야 한다.

#### 요구 페이징의 성능
- 페이지 폴트를 수행하기 위해 얼만큼의 시간이 필요한가?
  - 페이지 폴트 인터럽트 (짧다)
  - 페이지를 가져온다 (굉장히 길다)
  - 프로세스를 재시작한다 (짧다) 

#### Copy-On-Write(COW)
- 여러개의 프로세스가 같은 페이지를 공유하고, 한 프로세스가 페이지를 수정하려하면 공유한 페이지를 복사하여 수정한다. 
- fork()와 exec()를 사용하여 프로세스를 생성한다.

#### 페이지 교체
- 비어있는 프레임이 없으면 현재 사용하지 않는 것을 발견하고 해방시켜주자.
- 그 내용을 스와핑 공간에 작성하면서 프레임을 해방시켜 줄 수 있다.
- 그리고, 페이지 테이블도 페이지가 메모리에 존재하지 않는다고 수정하자.
- page fault가 발생하면 페이지 교체와 함께 일어나는 과정
  1. 보조 기억장치에서 요구된 페이지의 위치를 찾는다.
  2. 비어있는 프레임을 찾는다.
    - 만약 비어있으면, 그냥 사용한다.
    - 비어있는 프레임이 없으면, 페이치 교체 알고리즘을 사용하여 희생자 프레임을 고른다.
    - 희생자 프레임을 보조 기억장치에 옮긴다. 그에 따라 페이지 테이블을 수정한다.  
    - 요구된 페이지를 새롭게 해방된 프레임에 작성한다. 그에 따라 페이지 테이블을 수정한다.  
- 요구 페이징을 구현할 때 생기는 두 개의 주된 문제
  - 프레임 할당 알고리즘 : 각 프로세스 당 얼만큼의 프레임을 할당할 것인가?
  - 페이지 교체 알고리즘 : 어떤 프레임을 교체할 것인가? (보조기억장치 I/O 비용이 너무 비싸서
  요구 페이징 방법의 약간 향상이 시스템 성능에 커다란 이득을 가져올 수 있다.)

#### 페이지 교체 알고리즘의 평가
- reference string (참조 문자열) : 메모리 참조값을 여러개 묶어 놓은 것
- 특정 참조 문자열을 활용하여 알고리즘이 작동하는 동안 page fault가 얼마나 발생하는 지 계산해 보자. (최소화 하는 것이 목적)
- 페이지 프레임의 숫자는 당연히 프레임이 많을 수록 page fault는 적어진다.
- FIFO 페이지 교체 :
  - 가장 단순한 알고리즘
  - 교체될 페이지를 고를 때 가장 오래된 페이지를 고른다.
- Belady's anomaly
  - 할당된 프레임이 증가하면 페이지 폴트 비율이 줄어들어야 하는데 증가를 하는 부분이 있는 변칙 사례.
- OPT 또는 MIN 페이지 교체
  - 앞으로 가장 오랫동안 안 쓸것 같은 페이지를 교체한다.
  - page fault 비율이 가장 낮음을 보장한다. 
  - 하지만, 참조 문자열의 미래의 값을 필요로 한다. 따라서, 다른 알고리즘의 성능 비교 대조군으로만 쓰인다.
- LRU 페이지 교체 :
  - LRU(Least Recently Used)
  - 각 페이지에 가장 마지막 사용 시간을 연관시키고, 그 순간 가장 오랫동안 사용 안한 페이지를 고른다.
  - 가장 좋다고 여겨지고, 자주 사용된다.
  - 하지만, 가장 오랫동안 사용 안한지를 구별하는 것이 문제다.
  - 하드웨어의 상당한 보조가 필요하다. counter 또는 stack을 이용하여 구현할 수 있다. 
  - LRU는 OPT와 같이 Belady's anomaly를 겪지 않는다.
- Second-Chance 알고리즘 :
  - FIFO 페이지 교체 알고리즘을 활용한다.
  - 페이지 당 참조 비트를 설정하고, 만약 교체하고자 하는 페이지의 참조 비트가 0이면 교체를 한다.
  - 반대로, 참조 비트가 1이면 참조비트를 0으로 바꾸고, 도착 시간을 현재시간으로 바꾸고 다음 순서의 페이지를 교체한다.
  - LRU-approximation (LRU를 응용한 알고리즘이다. LRU는 하드웨어의 보조가 필요해서, 그대신 참조 비트를 사용한 것이다)

#### 프레임의 할당
- 동등하게 vs 비례하기
  - 동등 할당 : 모든 프로세스를 같은 양만큼 할당
  - 비례 할당 : 프로세스의 크기에 따라 할당
- 전역 vs 지역
  - 지역 교체 : 자기가 할당 받은 곳에서만 희생자 프레임을 골라 교체
  - 전역 교체 : 모든 프레임 중에서 희생자 프레임을 골라 교체

#### Thrashing
- 프로세스가 page in, page out 하느라 바쁜 상황
- 프로세스가 충분한 페이지를 가지지 않는다면 page fault 비율이 굉장히 높아진다.
- 멀티프로그래밍의 정도가 높아지면 그에 따라 CPU 활용도가 높아지는데 일정 정도를 넘어가면 오히려 CPU 활용도가 확 낮아지는 현상

#### Working-Set 모델
- 지역성의 가정에 따른 것이다.
- working-set : 가장 최근에 참조된 페이지들의 집합
- 만약 페이지가 사용된다면 working-set 안에 있을 것이고, 사용되지 않는다면 working-set 바깥에 있을 것이다.
- 따라서 working-set 바깥에 있는 것을 희생자 페이지로 고를 수 있다.
  
