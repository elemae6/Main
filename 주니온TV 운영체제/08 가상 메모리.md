# 가상 메모리
#### 가상 메모리란?
- 메모리에 완전히 있지 않는 프로세스들의 실행을 가능하게 해주는 기법
- 따라서, 프로그램은 메모리의 물리 주소 공간보다 더 큰 크기를 차지해도 된다.
- 주 메모리를 매우 큰 배열의 저장공간으로 추상화하여 논리적 메모리와 물리적 메모리를 분리한다.
- 현재 운영체제는 거의 다 가상 메모리가 있을 정도로, 파일 공유, 라이브러리 공유, 프로세스 생성에서도 효과적인 메커니즘을 제공한다.

#### 가상 주소 공간
<img src="https://user-images.githubusercontent.com/81418010/222339784-db079dc1-517c-4095-b7f7-7e78d362275d.png" height="300px" width="200px" align="right">
- 프로세스가 메모리에 저장된 논리적(혹은 가상의) 그림
- 보통, 0번지와 같은 특정 논리 주소로 시작되고, 연속적 메모리로써 존재한다.
- page sharing을 통해 파일과 메모리를 두 개 이상의 프로세스들로부터 공유하게 할 수 있다.

#### 요구 페이징 (demand paging)
- 실행가능한 프로그램이 보조기억장치에서 메모리에 어떻게 로딩될지 고려해보자.
- 한 가지 방법은 전체 프로그램을 물리적 메모리에 다 로딩하는 것이다.
- 다른 하나의 방법은 요구 페이징이다.
- 요구 페이징은 필요한 페이지만 로딩하는 것이다.
- 가상 메모리 시스템에서 흔하게 사용하고 있다.
- demand-paged virtual memory에서는 페이지는 실행이 요구될 때만 로딩된다.
- 프로세스가 실행될 때, 어떤 페이지는 메모리에 있고, 어떤 페이지는 보조기억장치에 있을 수 있다.
- 이 두가지 상황을 구별하려면, 유효-무효 비트 scheme이 사용될 수 있다.
  - 유효 : 페이지가 legal하며, 메모리에 존재한다. 
  - 무효 : 페이지가 유효하지 않거나 보조기억장치에 있지 않다.
- 페이지 폴트(Page fault)를 다루는 절차
  1. 프로세스의 내부 페이지 테이블을 확인하여 메모리 접근에 대한 참조가 유효한지 안한지 확인한다.
  2. 참조가 유효하면 프로세스를 종료시킨다. 하지만 유효하되, 페이지 폴트가 일어나면 page in을 한다.
  3. 비어있는 프레임을 찾는다. (free-frame list에서 하나 가져온다)
  4. 보조기억장치에 가서 요구된 페이지를 읽은 후 새롭게 할당한 프레임에 가져온다.  
  5. 가져온 이후, 내부 페이지 테이블을 수정한다. 페이지가 현재 메모리에 있다고 수정한다.
  6. 트랩에 의해 인터럽트 받은 명령어를 다시 수행한다.

#### 순수 요구 페이징 
- 메모리가 요구되기 전까지 절대 페이지를 가져오지 않는다.
- 따라서, 프로세스를 처음 시작할 때, 메모리에는 페이지가 하나도 없다.
- 그러면 첫 명령어가 페이지 폴트를 일으키고, 해당 페이지가 page in 된다.

#### 참조 지역성의 원리
- 프로그램이 여러 새로운 페이지를 각각의 명령어 마다 접근한다면, 
 만약, 명령어를 위한 한 페이지와, 데이터를 위한 여러 페이지의 경우, 명령어 마다 페이지 폴트를 일으킬 수 있다.
- 운좋게, 이러한 일을 잘 안일어난다.
- 프로그램은 참조 지역성의 원리를 가지려는 경향이 있다.
- 따라서, 요구 페이징을 사용하면 합리적인 수행을 할 수 있다.
- 자료구조와 프로그래밍 구조를 신중하게 고르면 코드와 데이터의 지역성을 높일 수 있다.
- 이런 이유로, 페이지 폴트 비율을 낮출 수 있고, 시스템의 성능을 향상시킬 수 있다.

#### 요구 페이징에 대한 하드웨어 지원
- 페이지 테이블 : 유효 비트, 무효 비트를 체크할 수 있다.
- 보조기억장치(스와핑 공간) : 주기억장치에 있지 않는 페이지들을 보관한다. 주로, 고속 디스크 또는 NVM장치이다.

#### 명령어 재시작
- 요구 페이징의 주요한 요구사항
  - 페이지 폴트 이후 아무 명령어나 재시작할 수 있게 해준다.
- 페이지 폴트가 일어나면, 인터럽트된 프로세스의 상태가 저장된다.(레지스터, 상태 코드, 명령어 카운터 등)
- 그러므로, 프로세스는 정확히 같은 장소와 상태에서 재시작한다.
- 페이지 폴트가 명령어 패치 중에 발생하면, 명령어 패치를 재시작하면 된다.
- 페이지 폴트가 피연산자를 패치하는 중 발생하면 다시 명령어를 패치한 후 피연산자를 패치한다.

#### Free frame list
- 페이지 폴트가 발생하면, 운영체제는 요구된 페이지를 보조 기억장치에서 주 기억장치로 가져와야 한다.
- 이러한 페이지 폴트를 해결하기 위해, 운영체제는 free frame list를 유지한다. 요구들을 만족하는 비어있는 프레임의 공동 이용 자원이다.
- free frame은 스택이나 힙 세그먼트를 통해 관리해줘야 한다.

#### 요구 페이징의 성능
- 페이지 폴트를 수행하기 위해 얼만큼의 시간이 필요한가?
  - 페이지 폴트 인터럽트 (짧다)
  - 페이지를 가져온다 (굉장히 길다)
  - 프로세스를 재시작한다 (짧다) 

#### Copy-On-Write(COW)
- 여러개의 프로세스가 같은 페이지를 공유하고, 한 프로세스가 페이지를 수정하려하면 공유한 페이지를 복사하여 수정한다. 
- fork()와 exec()를 사용하여 프로세스를 생성한다.




