# 프로세스   

#### 프로세스란?   
- 실행중인 프로그램
- 운영체제에서는 한 프로세스가 작업의 단위이다.
- 프로세스가 일을 하려면 필요한 자원<img src="https://user-images.githubusercontent.com/81418010/221090198-e1ec4adf-7e1e-4595-a189-728fd71816c4.png" height="280px" width="280px" align="right">
  - CPU 시간
  - 메모리
  - 파일 및 입출력 장치   
- 메모리에 로딩된후 CPU가 fetch할 수 있는 메모리 상의 프로그램이 프로세스다.
#### 프로세스의 메모리 레이아웃
- 텍스트 부분 : 실행가능한 코드
- 데이터 부분 : 전역 변수
- 힙 부분 : 실행 시간 중 동적할당되는 메모리 (ex. 자바의 new로 생성되는 객체)
- 스택 부분 : 함수의 매개변수, 리턴 주소값, 지역 변수 등..
- 소스코드 --(컴파일)--> a.out(프로그램) --(메모리에 로드)프로세스
- 운영체제는 (메모리에 로드)프로세스를 관리한다.
<img src="https://user-images.githubusercontent.com/81418010/221093714-12edb77b-b25d-40ae-aa6e-3fbaefc78604.png" height="200px" width="300px" align="right">
<img src="https://user-images.githubusercontent.com/81418010/221092145-07d97c2e-af75-42eb-a7f5-79b7912e6b9b.png" height="250px" width="130px" align="right">   

#### 프로세스 실행시 상태
- 생성 : 프로세스가 막 생성된 상태
- 준비 : 프로세스가 CPU에 실행되기 위해 대기하는 상태
- 실행 : 프로세스가 포함된 명령어가 실행되고 있는 상태
- 대기 : 프로세스가 특정 자원이나 이벤트를 기다리는 상태
- 종료 : 프로세스가 실행을 완료한 상태   
#### PCB(Process Control Block; 프로세스 제어 블록)
- 각 프로세스가 가져야할 정보를 포함하는, 운영체제 커널의 자료구조
- "PCB는 운영체제가 프로세스를 표현한 것이다."
- 포함된 정보
  - 프로세스 상태(생성, 준비, 실행 등...)
  - 프로그램 카운터 (Context의 요소)
  - CPU 레지스터 (Context의 요소)
  - CPU 스케줄링 정보
  - 메모리 관리 정보
  - 계정 정보
  - 입출력 상태 정보
      => 이러한 정보를 typedef struct 해서 P0, P1, P2 등으로 제어
<br><br>
- 과거에는 프로세스의 뜻은 한 개의 실행의 실타리를 수행하는 프로그램
- 하나의 실타래는 한 번에 하나의 일만 할 수 있다.
- 현대의 운영체제는 프로세스의 뜻을 한 개의 프로세스가 여러 개의 실행의 실타리를 수행할 수 있다고 확장되었다. 따라서 한 번에 여러 개의 일을 할 수 있게 되었다.
- 한 번에 한 가지 일만 할 것이면 운영체제와 같이 복잡한 소프트웨어가 필요없다. 이와 같이 운영체제의 핵심기능은 multitasking, multiprocessing이다. 과거에는 multiprocessing이 대세였지만 지금은 multithreading이 대세다.
<br><br>
- multiprogramming의 목표
  - 동시에 여러 프로세스를 실행시키자
  - CPU의 활용도를 최대화하자
- time sharing(시분할 시스템)의 목표
  - CPU의 코어를 프로세스 간의 자주 스위치해서 사용자가 각 프로그램이 동시에 작동하는 것처럼 보이게 하자
- 스케줄링 큐
  - 프로세스가 시스템에 들어가면 레디 큐에 들어간다.
  - 레디 큐에서 CPU의 코어에 의해 실행되도록 준비하고 대기한다.
  - 실제 구현은 PCB의 linked list로 구현된다.
#### Context Switch(문맥 교환)
  - 프로세스의 context(프로그램 카운터, CPU 레지스터)가 PCB에 나타난다.
  - 인터럽트를 발생시켜 실행되는 프로세스의 context를 저장하고, 나중에 재개될 때 context를 복구한다.
  - Context Switch가 하는 일
    - CPU Core를 다른 프로세스로 스위치한다.
    - 현재 프로세스의 상태를 저장한다.
    - 다른 프로세스의 상태를 복구한다.

` 따라서, 운영체제는 프로세스 생성, 프로세스 종료와 같은 기능을 제공해야 한다.
 운영체제의 핵심 기능이 multitasking이다.`
- 프로세스는 새로운 프로세스를 만들 수 있다. 
  - 생성하는 프로세스 : 부모 프로세스
  - 새로 생성된 프로세스 : 자식 프로세스
- fork()와 같은 system call인 운영체제의 서비스로 자식 프로세스를 만들 수 있다.
- 실행의 두 경우
  - 부모 프로세스와 자식 프로세스가 동시에 실행되는 경우.
  - 부모 프로세스가 자식 프로세스가 종료될 때까지 기다리는 경우.
- 주소 공간의 두 경우
  - 부모 프로세스와 자식 프로세스가 똑같은 일을 해서 자식 프로세스가 부모 프로세스의복제본인 경우.
  - 부모 프로세스와 자식 프로세스가 다른 일을 해서 자식 프로세스가 새로운 프로그램을 메모리에 로딩하는 경우.
<img src="https://user-images.githubusercontent.com/81418010/221104977-8e5f89c4-74c1-4afb-a1b6-1f2a6dacb45a.png" height="380px" width="440px" align="left">
<img src="https://user-images.githubusercontent.com/81418010/221105768-87115c5d-999a-4340-bb27-60eed3e33b63.png">
#### 프로세스 종료
- exit() system call을 호출하여 운영체제에 삭제를 대신 해달라고 요청
- 그러면 운영체제가 메모리 할당을 해제하고 메모리를 회수한다.
#### 좀비 프로세스, 고아 프로세스
- 좀비 프로세스 : 프로세스는 종료되었지만 부모 프로세스가 wait()를 호출 안한 프로세스
- 고아 프로세스 : 부모 프로세스가 wait()를 호출 안하고 종료된 프로세스










