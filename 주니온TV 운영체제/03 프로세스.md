# 프로세스   

#### 프로세스란?   
- 실행중인 프로그램
- 운영체제에서는 한 프로세스가 작업의 단위이다.
- 프로세스가 일을 하려면 필요한 자원<img src="https://user-images.githubusercontent.com/81418010/221090198-e1ec4adf-7e1e-4595-a189-728fd71816c4.png" height="280px" width="280px" align="right">
  - CPU 시간
  - 메모리
  - 파일 및 입출력 장치   
- 메모리에 로딩된후 CPU가 fetch할 수 있는 메모리 상의 프로그램이 프로세스다.
#### 프로세스의 메모리 레이아웃
- 텍스트 부분 : 실행가능한 코드
- 데이터 부분 : 전역 변수
- 힙 부분 : 실행 시간 중 동적할당되는 메모리 (ex. 자바의 new로 생성되는 객체)
- 스택 부분 : 함수의 매개변수, 리턴 주소값, 지역 변수 등..
- 소스코드 --(컴파일)--> a.out(프로그램) --(메모리에 로드)프로세스
- 운영체제는 (메모리에 로드)프로세스를 관리한다.<img src="https://user-images.githubusercontent.com/81418010/221092145-07d97c2e-af75-42eb-a7f5-79b7912e6b9b.png" height="250px" width="130px" align="right">


#### 프로세스 실행시 상태
- 생성 : 프로세스가 막 생성된 상태
- 준비 : 프로세스가 CPU에 실행되기 위해 대기하는 상태
- 실행 : 프로세스가 포함된 명령어가 실행되고 있는 상태
- 대기 : 프로세스가 특정 자원이나 이벤트를 기다리는 상태
- 종료 : 프로세스가 실행을 완료한 상태   
#### PCB(Process Control Block; 프로세스 제어 블록)
- 각 프로세스가 가져야할 정보를 포함하는, 운영체제 커널의 자료구조
- "PCB는 운영체제가 프로세스를 표현한 것이다."
- 포함된 정보<img src="https://user-images.githubusercontent.com/81418010/221124063-57f5fff3-1668-45b8-83c5-238ce98a949b.png" height="150px" width="400px" align="right">
  - 프로세스 상태(생성, 준비, 실행 등...)
  - 프로그램 카운터 (Context의 요소)
  - CPU 레지스터 (Context의 요소)
  - CPU 스케줄링 정보
  - 메모리 관리 정보
  - 계정 정보
  - 입출력 상태 정보
      => 이러한 정보를 typedef struct 해서 P0, P1, P2 등으로 제어
<br><br>
- 과거에는 프로세스의 뜻은 한 개의 실행의 실타리를 수행하는 프로그램
- 하나의 실타래는 한 번에 하나의 일만 할 수 있다.
- 현대의 운영체제는 프로세스의 뜻을 한 개의 프로세스가 여러 개의 실행의 실타리를 수행할 수 있다고 확장되었다. 따라서 한 번에 여러 개의 일을 할 수 있게 되었다.
- 한 번에 한 가지 일만 할 것이면 운영체제와 같이 복잡한 소프트웨어가 필요없다. 이와 같이 운영체제의 핵심기능은 multitasking, multiprocessing이다. 과거에는 multiprocessing이 대세였지만 지금은 multithreading이 대세다.
<br><br>
- multiprogramming의 목표
  - 동시에 여러 프로세스를 실행시키자
  - CPU의 활용도를 최대화하자
- time sharing(시분할 시스템)의 목표
  - CPU의 코어를 프로세스 간의 자주 스위치해서 사용자가 각 프로그램이 동시에 작동하는 것처럼 보이게 하자
- 스케줄링 큐
  - 프로세스가 시스템에 들어가면 레디 큐에 들어간다.
  - 레디 큐에서 CPU의 코어에 의해 실행되도록 준비하고 대기한다.
  - 실제 구현은 PCB의 linked list로 구현된다.
#### Context Switch(문맥 교환)<img src="https://user-images.githubusercontent.com/81418010/221104977-8e5f89c4-74c1-4afb-a1b6-1f2a6dacb45a.png" height="380px" width="440px" align="right">
  - 프로세스의 context(프로그램 카운터, CPU 레지스터)가 PCB에 나타난다.
  - 인터럽트를 발생시켜 실행되는 프로세스의 context를 저장하고, 나중에 재개될 때 context를 복구한다.
  - Context Switch가 하는 일
    - CPU Core를 다른 프로세스로 스위치한다.
    - 현재 프로세스의 상태를 저장한다.
    - 다른 프로세스의 상태를 복구한다.
  - Context Switch의 대상이 되는 두 프로세스는 각각 실행 상태, 준비 상태에 있다.
 
> 따라서, 운영체제는 프로세스 생성, 프로세스 종료와 같은 기능을 제공해야 한다.
> 운영체제의 핵심 기능이 multitasking이다.
- 프로세스는 새로운 프로세스를 만들 수 있다. 
  - 생성하는 프로세스 : 부모 프로세스
<img src="https://user-images.githubusercontent.com/81418010/221105768-87115c5d-999a-4340-bb27-60eed3e33b63.png" align="right">

  - 새로 생성된 프로세스 : 자식 프로세스
- fork()와 같은 system call인 운영체제의 서비스로 자식 프로세스를 만들 수 있다.
- 실행의 두 경우
  - 부모 프로세스와 자식 프로세스가 동시에 실행되는 경우.
  - 부모 프로세스가 자식 프로세스가 종료될 때까지 기다리는 경우.
- 주소 공간의 두 경우
  - 부모 프로세스와 자식 프로세스가 똑같은 일을 해서 자식 프로세스가 부모 프로세스의 복제본인 경우.
  - 부모 프로세스와 자식 프로세스가 다른 일을 해서 자식 프로세스가 새로운 프로그램을 메모리에 로딩하는 경우.

#### 프로세스 종료
- exit() system call을 호출하여 운영체제에 삭제를 대신 해달라고 요청
- 그러면 운영체제가 메모리 할당을 해제하고 메모리를 회수한다.
#### 좀비 프로세스, 고아 프로세스
- 좀비 프로세스 : 프로세스는 종료되었지만 부모 프로세스가 wait()를 호출 안한 프로세스
- 고아 프로세스 : 부모 프로세스가 wait()를 호출 안하고 종료된 프로세스

#### IPC(Inter-Process Communication)   <img src="https://user-images.githubusercontent.com/81418010/221325411-86473b29-7f38-4b83-958e-49868b4727b4.png" height="300px" width="400px" align="right">
- 동시에 실행되는 프로세스는
  - 프로세스 간에 데이터 공유 X  => 독립 프로세스
  - 프로세스 간에 데이터 공유 ㅇ  => 협동 프로세스  (프로세스 간에 영향을 주거나, 영향을 받는다.)
- 협동 프로세스는 데이터를 주고 받기 위한 IPC 메커니즘을 필요로 한다.
- 기본 IPC 모델 두 가지
  - 데이터 공유
  - 메시지 교환   

#### IPC - 데이터 공유 시스템
- 생산자-소비자 모델을 고려하자
  - 협동 프로세스의 개념을 설명하기 위해
  - 협동 프로세스의 흔한 패러다임
- 생산자-소비자 모델 :
  - 생산자는 정보를 생산하고 소비자는 그 정보를 소비한다.   
    예: 컴파일러(생산자)가 어셈블리 코드를 생산하고, 어셈블러(소비자) 그 코드를 소비한다.   
        웹 서버(생산자)가 HTML 파일을 생산하고, 웹 브라우저(소비자)가 그 파일을 소비한다.<img src="https://user-images.githubusercontent.com/81418010/221326187-c9136559-2211-49b0-9cc4-f16787730c83.png" height="150px" width="200px" align="right">

- 데이터 공유 시 생산자-소비자 모델을 활용
  - 생산자와 소비자가 동시에 실행될 때, 버퍼를 활용하여 생산자는 버퍼를 채우고, 소비자는 버퍼를 비운다.
  - 공유된 데이터의 영역이 생산자 프로세스와 소비자 프로세스가 공유하는 메모리의 영역이다.
  - 문제는 응용 프로그램을 만들 시 응용 프로그래머가 직접 공유된 데이터에 접근하는 코드와 조작하는 코드를 작성해야 한다.      

#### IPC - 메시지 교환   
- 운영체제가 협동 프로세스에 관한 도구(API)를 제공하여 메시지 교환을 통하여 소통할 수 있게 해준다.
- 공유된 메모리 영역은 운영체제가 알아서 관리한다.
- Communication Links: (P 프로세스와 Q 프로세스가 소통하려면 서로 '보내기'메시지, '받기'메시지를 보내야 한다.)
- Communication Link가 구현될 수 있는 다양한 방법
  - 직접 통신, 간접 통신
  - 동기화 통신, 비동기화 통신
  - 자동 혹은 명시적 버퍼링   
 
|직접 통신|간접 통신|
|-----|---|
|명시적으로 보내는 자, 받는자를 표시&nbsp;&nbsp;&nbsp;&nbsp;|메시지를 메일 박스 혹은 포트로 보내거나, 받는다<br>(메일박스(포트)서는 프로세스를 받아서 추가할 수 있고,<br>프로세스를 보내서 삭제할 수 있다|
|send(P, message) - P 프로세스에 메시지 전송<br>receive(Q, message) - Q 프로세스에 메시지 받기| send(A, message) - A 메일박스(포트)에 메시지 전송<br> receive(A, message) - A 메일박스(포트)에서 메시지 받기| 
|링크가 자동 생성| 두 프로세스 간에 메일 박스(포트)를 공유하면 링크를 생성|
|링크에는 오직 두 프로세스만 관련| 링크가 두 개 이상의 프로세스와 관련 가능<br>메일 박스(포트)에서 여러개의 메시지를 받고, 여러개의 메시지를 보낸다|
|두 프로세스 사이 하나의 링크| 두 프로세스 사이의 하나의 메일 박스(포트)를 경유한 링크가 여러개 존재 가능|   
> 따라서, 운영체제가 메일박스(포트)의 간접 통신을 위해 제공해야 하는 기능
> - 메일박스(포트) 생성
> - 메일박스(포트)에 메시지를 보내기
> - 메일박스(포트)에 메시지를 받기
> - 메일박스(삭제)
- 예) Port80에서 웹브라우저의 리스너 포트, Port23은 텔넬 포트
- 메일박스 구현시 다양한 설계 옵션 (예 Port8090을 만들고, 그 메일박스(포트)에 데이터를 send()를 써서 보내거나 receive()를 써서 받을 때)
 - blocking I/O or non-blocking I/O : 동기화 혹은 비동기화
   - blocking send : 보내는 자가 메시지를 받기 전까지 멈춘다(blocking). => 동기화   
   - non-blocking send: 보내는 자가 메시지를 보내고 할 일 한다. => 비동기화   
   - blocking receive : 받는 자가 메시지를 받을 때까지 멈춘다(blocking). => 동기화   
   - non-blocking receive: 받는 자가 메시지를 받으면 유효 메시지, 못 받으면 null 메시지를 받는다. => 비동기화   








