트랜잭션 격리 수준(Transaction Isolation Level)은 데이터베이스에서 동시에 실행되는 여러 트랜잭션들이 얼마나 서로에게 영향을 주는지를 정의하는 수준입니다. 트랜잭션 격리 수준은 데이터의 일관성과 동시성 사이의 균형을 조절하는 데 사용됩니다.

SQL 표준에서는 다음과 같은 네 가지 기본적인 트랜잭션 격리 수준을 정의하고 있습니다:

1. **Read Uncommitted (읽기 미커밋)**
    
    - 이 수준에서는 한 트랜잭션이 아직 커밋되지 않은 다른 트랜잭션의 변경사항을 읽을 수 있습니다. 이렇게 되면 Dirty Read가 발생할 수 있습니다. 동시성은 높지만, 데이터의 일관성은 낮습니다.
2. **Read Committed (읽기 커밋)**
    
    - 이 수준에서는 트랜잭션은 오직 커밋된 데이터만 읽을 수 있습니다. 따라서 Dirty Read는 발생하지 않지만, Non-Repeatable Read는 발생할 수 있습니다.
3. **Repeatable Read (반복 읽기)**
    
    - 이 수준에서는 트랜잭션 동안 동일한 쿼리의 결과가 항상 동일하게 반복 가능하도록 보장됩니다. Dirty Read와 Non-Repeatable Read는 발생하지 않지만, Phantom Read는 발생할 수 있습니다.
4. **Serializable (직렬화 가능)**
    
    - 이것은 가장 엄격한 트랜잭션 격리 수준입니다. 트랜잭션들은 순차적으로 실행되어야 하므로, Dirty Read, Non-Repeatable Read, Phantom Read 모두 발생하지 않습니다. 그러나 이런 엄격한 제약 때문에 동시성이 낮아질 수 있습니다.

각 격리 수준은 데이터의 일관성과 동시성 사이의 균형을 다르게 가져갑니다. 따라서 실제 사용 시에는 애플리케이션의 요구 사항과 워크로드 특성을 고려하여 적절한 트랜잭션 격리 수준을 선택해야 합니다.

---

"Phantom Read", "Non-Repeatable Read", "Dirty Read"는 데이터베이스에서 발생할 수 있는 트랜잭션 격리성(isolation) 문제들을 설명하는 용어들입니다. 각 문제는 동시에 여러 트랜잭션이 수행될 때 발생할 수 있습니다. 이러한 문제들을 이해하는 것은 트랜잭션의 격리 수준(isolation level)을 결정하는 데 중요합니다.

1. **Dirty Read**
    
    - 한 트랜잭션이 아직 커밋되지 않은 변경된 데이터를 읽을 때 발생하는 현상입니다. 예를 들어, 트랜잭션 A가 어떤 데이터를 변경했지만 아직 커밋하지 않았는데, 트랜잭션 B가 그 변경된 데이터를 읽는 경우 Dirty Read가 발생합니다. 만약 트랜잭션 A가 롤백된다면, 트랜잭션 B는 실제로 존재하지 않는 데이터를 읽었게 됩니다.
2. **Non-Repeatable Read**
    
    - 한 트랜잭션 내에서 동일한 데이터를 두 번 이상 읽을 때, 두 번째 읽기 작업에서 첫 번째 읽기 작업과 다른 값을 반환할 때 발생하는 현상입니다. 예를 들어, 트랜잭션 A가 어떤 데이터를 읽고, 그 사이에 트랜잭션 B가 그 데이터를 수정하고 커밋한다면, 트랜잭션 A의 두 번째 읽기 작업은 첫 번째와 다른 결과를 반환합니다.
3. **Phantom Read**
    
    - 한 트랜잭션에서 특정 조건으로 데이터를 여러 번 읽을 때, 후속 읽기 작업에서 처음의 읽기 작업과 다른 행의 집합을 반환할 때 발생하는 현상입니다. 예를 들어, 트랜잭션 A가 어떤 조건으로 데이터를 읽고, 그 사이에 트랜잭션 B가 그 조건에 해당하는 새로운 행을 추가하거나 제거하고 커밋한다면, 트랜잭션 A의 후속 읽기 작업은 추가되거나 제거된 "유령(phantom)" 행을 보게 됩니다.

이러한 문제들을 해결하거나 관리하기 위해, 대부분의 데이터베이스 관리 시스템(DBMS)은 여러 격리 수준을 제공합니다. 격리 수준에 따라 트랜잭션 간의 동시성과 데이터의 일관성 사이에 균형을 맞출 수 있습니다.

| |Phantom Read|Non-Repeatable Read|Dirty Read|
|---|:---:|:---:|:---:|
|Serializable|X|X|X|
|Repeatable Read|O|X|X|
|Read Committed|O|O|X|
|Read Uncommitted|O|O|O|

---

"Repeatable Read"는 트랜잭션 격리 수준 중 하나로, 동시에 여러 트랜잭션이 실행될 때 어떤 상호 작용을 허용할 것인지를 정의하는 것입니다. "Repeatable Read"의 주요 특징과 작동 방식에 대해 더 자세히 설명하겠습니다.

### Repeatable Read의 주요 특징:

1. **동일한 데이터 반복 읽기 보장**: 한 트랜잭션 내에서 동일한 데이터를 여러 번 읽을 때, 그 결과는 항상 동일하게 보장됩니다. 다른 트랜잭션에서 그 사이에 해당 데이터를 변경하려고 해도, 원래 트랜잭션에서는 그 변경사항을 보지 못하게 됩니다.
    
2. **Dirty Read 방지**: "Dirty Read"는 한 트랜잭션이 아직 커밋되지 않은 다른 트랜잭션의 변경사항을 읽는 현상을 말합니다. "Repeatable Read"에서는 이러한 현상이 발생하지 않습니다.
    
3. **Non-Repeatable Read 방지**: 위에서 설명한 것처럼, "Repeatable Read" 격리 수준에서는 동일한 데이터의 여러 번의 읽기 연산이 항상 동일한 결과를 반환하도록 보장됩니다.
    
4. **Phantom Read 발생 가능**: 그러나 "Repeatable Read" 격리 수준에서는 "Phantom Read" 현상이 발생할 수 있습니다. 이는 쿼리의 결과 집합에 새로 추가되거나 제거된 레코드 때문에 동일한 쿼리가 다른 결과 세트를 반환할 때 발생합니다.
    

### Repeatable Read의 작동 방식:

"Repeatable Read" 격리 수준에서는, 트랜잭션 내에서 읽은 데이터에 대한 공유 락(Shared Lock)을 유지하게 됩니다. 이 락은 해당 데이터가 해당 트랜잭션에 의해 읽힌다는 것을 다른 트랜잭션들에게 알리는 역할을 합니다. 이 공유 락 때문에, 다른 트랜잭션은 해당 데이터를 변경할 수 없게 됩니다.

그러나 "Repeatable Read" 격리 수준에서는 행 레벨 락만을 사용하기 때문에, 쿼리의 조건에 맞는 새로운 레코드가 추가되거나 삭제되는 것을 방지하지 못합니다. 따라서 "Phantom Read" 현상이 발생할 수 있습니다.

대부분의 데이터베이스 관리 시스템(DBMS)은 여러 격리 수준을 제공하며, "Repeatable Read"는 이 중 하나입니다. 사용자는 워크로드와 요구 사항에 따라 적절한 격리 수준을 선택해야 합니다.